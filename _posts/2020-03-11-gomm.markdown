---
layout: post
title:  "The Go Memory Model"
date:   2020-03-11 14:00:00 +0100
categories: programming-languages
---
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

# Memory models

At the end of the [previous post][mmp1], we saw that a compiler can change the order of instructions in a binary (as long as *single threaded semantics* is preserved).  These changes can break synchronization, especially if we expect to synchronize by reading and writing to variables.
When pondering about synchronization, it would be unreasonable to expect a programmer to peek into the compiler.  Luckily, languages come with a *memory model*: a document that serves as a contract between the programmer and the compiler.

Programmers expect clear constructs and clear explanations of these constructs.  Compiler writers want freedom to implement optimizations and freedom to evolve a language.   These two camps are at odds and it is the job of a language's memory model to bring these camps together.  Regardless of the complexity of the optimizations, a program shall behave as described by the model.

Defining a reasonable memory model is then juggling act.  We will look at a real-world memory model soon.  But first, let us cover some of the concepts and terms used in the specification of memory models.


## The *happens-before* relation

Software memory models are usually described in terms of the *happens-before* relation.  Lamport [introduced the concept][lamport78] in 1978 when studying the relative order of events in distributed systems.  Today, the happens-before has become a vehicle for speaking of memory, for defining data races, etc.

The happens-before relation is a mathematical construct.  You shouldn't read "happens-before" and think in terms of natural language.  Here are two ways in which our intuition about the words "happens before" breaks.  First, happens-before does not necessarily imply an order of execution.  Even if `A` is in happens-before relation to `B`, it is still possible for `B` to occur before `A` in an execution.  Hum...    Second, even if `A` necessarily occurs before `B`, it is still possible for `A` and `B` to not be related by happens-before.  Double "hum..."

Going back to our good old example from the [previous post][mmp1].

```
     T1             |    T2
z    = 42       (A) |   if (done)    (C)
done = true     (B) |     print(z)   (D)
```

We saw that it is possible for `A` not to be executed before `B`; this observation comes despite of the fact that `A` is in happens-before relation to `B` (as it will become clear later).
Also, even though `B` occurs before `D` in every execution, it does not mean that `B` is in happens-before relation to `D`.  These facts may seem confusing now but, by the time you finish reading, it should all be much clearer.

Instead of using our intuition when thinking about *happens-before*, we will apply a definition.  Let us write *happens-before* as $\rightarrow_{hb}$.  Similar to how $<$ is a relation between numbers, the happens-before relation is a relation between events. To be more precise, $\rightarrow_{hb}$ is a relation between events emanating from a program's execution.

Let $a$, $b$, and $c$ be events.  For example, $a$ could be the reading of a variable by a thread.  Event $b$ could be a write to another variable by another thread.  Event $c$ could be some synchronization operation.  The happens-before relation was originally defined in terms of message-passing as follows:

1. If $a$ occurs before $b$ within the same process, then $a \rightarrow_{hb} b$,
2. If $a$ is the sending of a message and $b$ is the message reception, then $a \rightarrow_{hb} b$,
3. If $a \rightarrow_{hb} b$ and $b \rightarrow_{hb} c$ then $a \rightarrow_{hb} c$.

Notice that *rule (1)* above captures the preservation of single threaded semantics.  Single thread semantics means that instructions within a thread must appear to be executed in program-order.  The compiler may still reorder read and writes within a thread, as long as the thread can't tell the difference.

Note also that, although happens-before was originally defined by Lamport in terms of message passing, today, the concept is used to described various types of systems.  It is common, for example, to describe locks in terms of the happens-before relation.

Finally, *rule (3)* means that the happens-before relation, like the less-than relation, is transitive.  For example, since $3 < 5$ and $5 < 10$ then $3 < 10$.

We are now prepared to look into the [Go memory model][gomm].  But we will have to do a little trespassing...


## Reasoning with the Go memory model

The [Go memory model][gomm] starts with the following ominous trespassing sign:

> If you must read the rest of this document to understand the behavior of your program, you are being too clever.
>
> Don't be clever. 

Feeling clever?  Then come on in!

The Go memory model lays out the rules for what values can be read from memory given previous writes to memory from different threads (or goroutines as they are called in Go).  It uses the happens-before relation to precisely describe when a read operation can observe given write.  Go defines the happens-before relation slightly different from Lamport.  It says:

1. Instructions within a thread are in happens-before relation.  (Same as Lamport)
2. A send onto a channel happens-before the corresponding receive from that channel completes.  (Almost the same as Lamport)
3. The $k^{th}$ receive from a channel with capacity $C$ happens-before the $(k+C)^{th}$ send onto that channel completes.  (New compared to Lamport)

There are a few other rules not mentioned above, such as rules about spawning new threads (or Go routines).  But we don't need them right now.  Rules (1), (2), and (3) above will give us plenty to think about.

Let us revisit our good old example.

```
     T1         |    T2
z    = 42       |   if (done)
done = true     |     print(z)
```

We saw that this program is properly synchronized given a *strong* or *sequentially consistent* memory model.  However, under weak memory, `T2` can observe `T1`'s instructions as if they were executed out of program order.  Given this swapping of `T1`'s instructions, the program is not properly synchronized and `T2` may print an uninitialized value of `z`.

Let revisit this example from the perspective of the Go memory model.  Again, let us label the statements in the program `A`, `B`, `C` and `D`:

```
     T1            |    T2
z    = 42     (A)  |   if (done)     (C)
done = true   (B)  |     print(z)    (D)

    A →hb B            C →hb D
```

Given rule (1) from the Go memory model, we infer that `A` $\rightarrow_{hb}$ `B` and that `C` $\rightarrow_{hb}$ `D`.  But that is all we get!  There is no way to relate events from thread `T1` to events of thread `T2`.  Given the fact that the instructions in `T1` and `T2` are not related by happens-before, it is possible for `D` to occur before `A` in an execution.

If we want to fix this program and make sure `T2` will necessarily print `42`, then we must ensure that `A` happens-before `D`.  How can we do that?!  In Go, we use channels.  Let us replace the setting of `done` and the checking of `done` with a send on a channel `c` and a receive from that channel:

```
     T1            |    T2
z    = 42     (A)  |   <- c        (C)
c   <- true   (B)  |   print(z)    (D)

    A →hb B            C → D

               B →hb C
```

The statement `c <- true`, with the arrow pointing *into* the channel, means that we are sending the value of `true` on the channel.  The statement `<- c`, with the arrow pointing *away* from the channel, means we are receiving a value from the channel.

Because the receive operation is blocking, meaning, it will block until there is something to be received, we know that the receive will only occur once the sent has occurred.  Given rule (2) from the Go memory model, which says that "a send happens-before the corresponding receive completes", we now have `B` $\rightarrow_{hb}$ `C`.  Rule (2) allowed us to relate events from different thread.

At this point we have:

- `A` $\rightarrow_{hb}$ `B` by rule 1, program-order
- `B` $\rightarrow_{hb}$ `C` by rule 2, send happens-before completion of receive
- `C` $\rightarrow_{hb}$ `D` by rule 1, program order.

By transitivity of the happens-before relation, we can then conclude that `A` $\rightarrow_{hb}$ `D`.   We have thus reasoned that this program will necessarily print `42`.  Neat!


## Much ado about something

In this post we used the Go memory model and the happens-before relation to fix a program that was not properly synchronized, we used channels to obtain a new program that is properly synchronized, and we employed the happens-before relation to rigorously reason about the correctness of new program.

You may be wondering... that was a lot of work in order to show that a four line program works as intended.  Indeed.  We are building concepts and mathematical tools for reasoning about programming languages and programs.  It takes effort.  But the effort can have big pay-offs.  Later we will see how these same concepts and tools helped expose a bug that existed undetected in Go for many years.


[mmp1]: /programming-languages/2020/03/05/memory-models.html
[gomm]: https://golang.org/ref/mem
[lamport78]: https://dl.acm.org/doi/abs/10.1145/3335772.3335934
